<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript,javascript语言精粹," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="函数函数包含一组语句，是js的基础模块单元，用于代码复用、信息隐藏和组合调用。一般来说函数用于指定对象的行为。">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript good parts 函数">
<meta property="og:url" content="http://guilongyue.github.io/2017/03/01/javascriptGoodParts4/index.html">
<meta property="og:site_name" content="沉默的风">
<meta property="og:description" content="函数函数包含一组语句，是js的基础模块单元，用于代码复用、信息隐藏和组合调用。一般来说函数用于指定对象的行为。">
<meta property="og:updated_time" content="2017-03-23T10:15:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript good parts 函数">
<meta name="twitter:description" content="函数函数包含一组语句，是js的基础模块单元，用于代码复用、信息隐藏和组合调用。一般来说函数用于指定对象的行为。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://guilongyue.github.io/2017/03/01/javascriptGoodParts4/"/>





  <title> javascript good parts 函数 | 沉默的风 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">沉默的风</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://guilongyue.github.io/2017/03/01/javascriptGoodParts4/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="guilong yue">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="沉默的风">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="沉默的风" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                javascript good parts 函数
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-01T22:00:13+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/javascriptGoodParts4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/javascriptGoodParts4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数包含一组语句，是js的基础模块单元，用于代码复用、信息隐藏和组合调用。一般来说函数用于指定对象的行为。<br><a id="more"></a></p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>在js中函数就是对象，对象是名/值对的集合并用一个连到原型对象的隐藏连接。对象字面量产生的对象连接到Object.prototype .函数对象连接到Function.prototye.（该原型对象本身连接到Object.prototype）；每个函数在创建时附有两个附加的隐藏属性。函数的上下文和实现函数行为的代码。<br><strong>每个函数对象在创建时也随带了一个prototype属性，他的值是一个拥有constructor属性且值为该函数的对象。这和隐藏连接到Function.prototype完全不同，这个令人费解的构造过程的意义。</strong><br>因为函数是对象，所以他们可以像任何其他值一样被使用，函数可以存放在变量、对象、数组中，函数可以被当做参数传递给其他函数，函数也可以在返回函数，因为函数是对象，所以函数可以拥有方法。<br>函数的与众不同之处在于他们可以被调用。</p>
<h3 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h3><p>函数对象可以通过对象字面量来创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var add = function(a,b)&#123;</div><div class="line">	return a+b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数字面量包括4个部分，第一部分function保留字。<br>第二部分函数名，它可有被省略，函数名可以用来递归的调用自己。如果没有函数名，则为匿名函数。<br>第三，是包在（）中的参数，每个参数用，分隔，这些名称将被定义为函数中的变量，他们不想普通变量那样被初始化为undefined。而是在该函数被调用时初始化为函数被调用时实际提供的参数值。<br>第四部分是{}中的一组语句，是函数的主体，他们在函数被调用时执行。他们在函数被调用时执行。<br><strong>函数字面量可以出现在任何允许表达式出现的地方，函数可以出现在函数中，一个内部函数自然可以访问自己的参数和变量，同时他也能方便的访问，他被嵌套在其中的那个函数的参数和变量，通过函数字面量创建的函数对象包含一个连到外部上下文的连接。这被称为闭包，这是js强大表现力的根基。</strong></p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用一个函数将停止当前函数的执行，传递控制权和参数给新函数，处理声明时定义的参数，<strong>每个函数接受两个附加的参数，this和arguments。参数this在面向对象编程是非常重要，他的值取决于调用的模式。在js中一共有四种调用模式，方法调用模式，函数调用模式，构造器调用模式，apply调用模式。这些模式在初始化this上存在差异。</strong><br>调用运算符是跟在任何一个产生函数值的表达式之后的一对（），()内包含一个或多个由，隔开的表达式，每个表达式产生一个参数值，每个参数值被赋予函数声明时是定义的形式参数名，当实际参数arguments与形参parameters个数不一致时不会产生运行时错误，如果参数值过多，多出的被忽略，过少，缺少的参数值被替换为undefined。对参数值不会行进类型检查，任何类型的值都可以传递给参数。</p>
<h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p>当一个函数被保存为对象的属性时，我们称它为一个方法，当一个方法被调用时，this绑定到该对象，如果一个调用表达式包含一个属性存取表达式(.或[subscript]表达式)，那么他被当做方法调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	value:0,</div><div class="line">	increment：function(inc)&#123;</div><div class="line">		this.value += typeof inc === &apos;number&apos; ? inc :1;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">myObject.increment(); </div><div class="line">myObject.value; //1</div><div class="line">myObject.increment(2);</div><div class="line">myObject.value; //3</div></pre></td></tr></table></figure></p>
<p>方法可以用this访问对象，所以他能从对象中取值或修改该对象，this到对象的绑定发生在函数调用时，这个超级“迟”绑定,使得函数对this高度复用，通过this可取的他们所属对象上下文的方法称为公共方法。</p>
<h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p>当一个函数并非一个对象的方法时，那么他被当做函数调用。<br>当函数以此模式调用时，this被绑定到全局对象，这是语言设计上的一个错误，倘若设计正确，当内部函数被调用时，this应该绑定到外部函数的this变量，因为内部函数的this不绑定了错误的值，如果该方法定义了一个变量并给它赋值为this，那么内部函数就可以通过那个变量访问到this。按照约定，变量命名为that。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">myObject.double = function()&#123;</div><div class="line">	var that = this;</div><div class="line">	var helper = function()&#123;</div><div class="line">		that.value = add();</div><div class="line">	&#125;</div><div class="line">	helper();</div><div class="line">&#125;</div><div class="line">myObject.double();</div></pre></td></tr></table></figure></p>
<h4 id="构造器的调用模式"><a href="#构造器的调用模式" class="headerlink" title="构造器的调用模式"></a>构造器的调用模式</h4><p>js是一门基于“原型继承”的语言，对象可以直接从其他对象继承属性，该语言是无类别的。<br>它提供了一套和基于类相似的对象构建语法。<br>如果一个函数前面加上new来调用，那么将创建一个隐藏连接到该函数的prototype成员的新对象，同时this将会绑定到这个新对象上。<br>new 前缀也会改变return 语句的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//创建一个名为Quo的构造器函数，它构造一个带有status属性的对象。</div><div class="line">var Quo = function(string)&#123;</div><div class="line">	this.status = = string;</div><div class="line">&#125;</div><div class="line">//Quo的所有实例增加一个名为get_status的公共方法。</div><div class="line">Quo.prototype.get_status = funtion()&#123;</div><div class="line">	return this.status;</div><div class="line">&#125;</div><div class="line">//构建一个Quo实例。</div><div class="line">var myQuo = new Quo(&quot;confused&quot;);</div><div class="line">myQuo.get_status();</div><div class="line"></div><div class="line">myQuo.__proto__ === Quo.prototype; //true 自己写的</div></pre></td></tr></table></figure></p>
<p>目的就是结合new发前缀调用的函数被称为构造器函数，按照约定保存在大写格式命名的变量里，如果构造器函数前面没有加上new，可能会造成非常严重的问题。</p>
<h4 id="Apply调用模式"><a href="#Apply调用模式" class="headerlink" title="Apply调用模式"></a>Apply调用模式</h4><p>因为js是一门函数式的面向对象的编程语言，所以函数可以拥有方法。<br>apply方法让我们去构建一个参数数组去调用函数，他也允许我们选择this的值。<br>apply方法接受两个参数，第一个是绑定给this的值，第二个是一个参数数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var array = [3,4];</div><div class="line">var sum = add.apply(null,array);</div><div class="line"></div><div class="line">var statusObject = &#123;</div><div class="line">	status:&apos;status-ok&apos;</div><div class="line">&#125;;</div><div class="line">var status = Quo.prototype.get_status.apply(statusObject); //&apos;status-ok&apos;</div></pre></td></tr></table></figure></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>当函数被调用时会得到一个免费奉送的参数，那就是arguments数组，通过它函数可以访问所有他被调用时，传递给它的参数列表，包括哪些没有分配给函数声明时定义的形式参数的多与参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var sum = function()&#123;</div><div class="line">	var i,sum = 0;</div><div class="line">	for(i =0 ;i&lt;arguments.length;i++)&#123;</div><div class="line">		sum = sum + arguments[i];</div><div class="line">	&#125;</div><div class="line">	return sum;</div><div class="line">&#125;</div><div class="line">documents.writeln(sum(1,2,3,4));</div><div class="line">//这不是一个特别有用的模式，数组可以添加相似的方法实现。</div><div class="line">arguments不是一个真正的数组对象，他只是一个ayyay-like对象，arguments拥有一个length属性，但他缺少所有的数组方法。</div></pre></td></tr></table></figure></p>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>当一个函数被调用时，他从第一句开始执行，并在遇到关闭函数体}时结束。那使得函数把控制权交还给调用该函数的程序部分。<br>return语句可用来使函数提前返回，当return被执行时，函数立即返回而不再执行余下的语句。<br><strong>一个函数总是会返回一个值，如果没有指定返回值，则返回undefined。</strong><br>如果函数的前面加new前缀的方式进行调用，且返回值不是一个对象。则返回this(该新对象)。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>js提供了一套异常处理机制，异常时干扰程序的正常流程的事故，当查出这样的事故，你的程序应该抛出一个异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var add = function(a,b)&#123;</div><div class="line">	if(typeof a !== &apos;number&apos; typeof !== &apos;number&apos;)&#123;</div><div class="line">		throw&#123;name:&apos;TypeError&apos;,</div><div class="line">				message:&apos;add need numbers&apos;</div><div class="line">			&#125;;</div><div class="line">	&#125;</div><div class="line">	return a+b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>throw语句中断函数的执行，它应该抛出一个exception对象，该对象包含可识别异常类型的name属性和一个描述性的message属性，你也可以添加其他属性。<br>该exception对象将被传递到try语句的catch从句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var try_it = function()&#123;</div><div class="line">	try&#123;</div><div class="line">		add(&apos;seven&apos;);</div><div class="line">	&#125;catch(e)&#123;</div><div class="line">		document.writeln(e.name+&quot;:&quot;+e.message);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">try_it();</div></pre></td></tr></table></figure></p>
<p>try代码块抛出一个异常，控制权就会跳到catch从句。</p>
<h3 id="给类型增加方法。"><a href="#给类型增加方法。" class="headerlink" title="给类型增加方法。"></a>给类型增加方法。</h3><p>js允许给语言的基本类型增加方法，通过给Object.prototype对象增加方法使得该方法对所有对象适用。这样的方法对函数、数组、字符串、数字、正则表达式和布尔值同样适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function(name,func)&#123;</div><div class="line">	this.prototype[name] = func;</div><div class="line">	return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过给Function.prototype对象增加一个method方法，我们就不必键入这个属性名。这个缺点就被掩盖了。<br>js没有单独的整数类型，因次只提取数字中的整数部分是有必要的，js本身提供的取整方法有些丑陋，我们可以给Number.prototype增加integer方法，他会根据数字的政府使用Math。ceiling还是Number.floor。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Number.method(&apos;integer&apos;,function()&#123;</div><div class="line">	return Math[this&lt;0?&apos;ceiling&apos;,&apos;floor&apos;](this);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>js缺少一个移除字符串末端空白的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String.method(&apos;trim&apos;.function()&#123;</div><div class="line">	return this.replace(/^\s+|\s+$/g,&apos;&apos;);</div><div class="line">&#125;);</div><div class="line">document.writeln(&apos; neat  &apos;.trim());</div></pre></td></tr></table></figure></p>
<p>我们的trim方法使用了一个正则表达式。<br>通过给基本类型增加方法，因为js原型继承的动态本质，新的方法被立即赋予到所有的值(对象实例)上。哪怕值是在方法创建之前就已创建好了。<br>基本类型的原型是公共的结构，一个确定的方法是在确定没有改方法是才添加它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function(name,func)&#123;</div><div class="line">	if(!this.prototype[name])&#123;</div><div class="line">		this.prototype[name] = func;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">&apos;hello&apos;.__proto__ === String.prototype //true</div><div class="line">typeof String === &apos;function&apos; //true</div></pre></td></tr></table></figure></p>
<p>另一个需要注意的是for in在原型上表现的很糟糕，可以用hasOwnProperty()</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数是直接或间接调用自身的一种函数，一个递归函数调用自身解决它的子问题。<br>递归函数可以高效的操作树形结构，比如浏览器的文档对象模型，每次递归调用时处理调用树的一小段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">定义walk_the_dom函数</div><div class="line">var walk_the_dom = function walk(node,func)&#123;</div><div class="line">	func(node);</div><div class="line">	node = node.firstChild;</div><div class="line">	while(node)&#123;</div><div class="line">		walk(node,func);</div><div class="line">		node = node.nextSibling;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var getElementsByAttribute = function(att,value)&#123;</div><div class="line">	var results = [];</div><div class="line">	walk_the_dom(documnet.body,function(node)&#123;</div><div class="line">		var actual = node.nodeType === 1 &amp;&amp; node.getAttribute(att);</div><div class="line">if(typeof actual === &apos;string&apos; &amp;&amp; (actual === value || typeof value !== &apos;string&apos;) )&#123;</div><div class="line">	results.push(node);</div><div class="line">&#125;</div><div class="line">		</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">*	几乎所有语言中||和&amp;&amp;都遵循“短路”原理，</div><div class="line">*	如&amp;&amp;中第一个表达式为假就不会去处理第二个表达式，而||正好相反。</div><div class="line">*	js也遵循上述原则。</div><div class="line">*	当||时，找到为true的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。</div><div class="line">*	当&amp;&amp;时，找到为false的分项就停止处理，并返回该分项的值。</div></pre></td></tr></table></figure></p>
<p>一些语言提供了尾递归优化。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域控制着变量与参数的可见性与生命周期，js确实有函数作用域，那意味着定义在函数中的参数和变量，在函数外不可见，<strong>而且在一个函数中任意位置的变量在该函数中的任何地方都可见。</strong><br>最好的做法是在函数体的顶部声明函数中声明所有可能用到的变量。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>作用域的好处是可以是内部函数可以访问定义在他们的外部函数的参数和变量（除了this和arguments）。<br>一个有趣的现象是内部函数拥有比其外部函数更长的生命周期。<br>之前，我们定义了myObject不同，他拥有一个value属性和increment方法，假定我们希望保护该值不被更改。<br>和以对象字面量的方式，初始化该对象不同，我们以函数调用的方式初始化对象。value对函数内部的方法是可用的，但对函数外部来说是不可见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject =function（）&#123;</div><div class="line">	var value = 0；</div><div class="line">	return &#123;</div><div class="line">		increment:function(inc)&#123;</div><div class="line">			value += typeof inc !== &apos;number&apos;?1:inc;</div><div class="line">		&#125;,</div><div class="line">		getValue:function()&#123;</div><div class="line">			return value;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>该方法返回一个包含两个方法的对象，并且方法依然具有value的访问权。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var quo  = function(status)&#123;</div><div class="line">	return &#123;</div><div class="line">		get_status:function()&#123;return status;&#125;;</div><div class="line">	&#125;</div><div class="line">&#125; ;</div><div class="line">var myquo = quo(&quot;amazed&quot;);</div><div class="line">myquo.get_status();</div></pre></td></tr></table></figure></p>
<p>这个quo函数被设计成无须用new 调用，当被调用时它返回一个包含get_status方法的新对象，该对象的一各引用保存在Myquo中，即使quo已经返回了，但get_status方法仍然可以访问quo对象的status属性，因为函数可以访问他被创建时的上下文环境。这被称为闭包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//一个有趣的例子，设置DOM节点背景有黄色变为白色。</div><div class="line">var fade = function (node)&#123;</div><div class="line">	var level =0 ;</div><div class="line">	var step = function()&#123;</div><div class="line">		var hex = level.toString(16);</div><div class="line">		node.style.backgroundColor = &apos;#FFFF&apos;+hex+hex;</div><div class="line">		if(level&lt;15)&#123;</div><div class="line">			level+=1;</div><div class="line">			setTimeout(step,100);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	setTimeout(step,100);</div><div class="line">&#125;</div><div class="line">fade(document.body);</div><div class="line"></div><div class="line">我犯了一个错误。</div><div class="line">把fade放在body最下面即可。</div></pre></td></tr></table></figure></p>
<p>我们调用fade，把document.body作为参数传递给它，fade函数设置level为1，它定义了一个step函数，接着调用setTimeout把step函数和一个时间给它，然后它返回fade函数结束。<br>在大约100毫秒后，step函数被调用，他把fade函数的level变量转换为16进制，接着他修改node节点背景颜色，然后查看fade函数的level变量，若果背景色尚未变成白色，那么它增加level变量，和setTimeout预定让自己再次运行。<br>step函数再次被调用，但这次fade函数的level变量变为2，fade函数在之前已经返回了，但只要fade的内部函数需要，它的变量就会持续保留。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">add_the_handlers =function(nodes)&#123;</div><div class="line">	var i;</div><div class="line">	for(i=0;i&lt;nodes.length;i+=1)&#123;</div><div class="line">		nodes[i].onclick = function(i)&#123;</div><div class="line">			return function(e)&#123;</div><div class="line">				alert(e);</div><div class="line">			&#125;;</div><div class="line">		&#125;(i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们创建一个函数，并传递i进去执行，而不是吧一个函数赋值给onclick。那个函数将返回一个时间处理器函数，这个处理器函数返回的是传递进去的i的值，而不是定义在add_the_handlers函数里的i的值，那个被返回的函数被赋值给onclick。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>函数可以让不连续事件的处理更容易，</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是一个提供接口却隐藏状态与实现的函数或对象。通过使用函数去产生模块，我们几乎可以放弃全局变量的使用。<br>假定我们要给String增加一个deentityify方法，他的任务是寻找字符串的HTML字符实体并替换他们对应得字符。在一个对象中保存字符实体的名字和他们对应的字符是有意义的，我们可以把它放到一个全局变量中，但全局变量时魔鬼。我们可以把它放在函数本身，但是哪有运行时的损耗，因为该函数在每次执行的时候改字面量就会被求值一次，理想的方式是将其放入一个闭包，而且也许还能提供一个增加更多字符实体的扩展方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">String.method(&apos;deentityify&apos;,function()&#123;</div><div class="line">	//字符实体表</div><div class="line">	var entity = &#123;quot:&apos;&quot;&apos;,lt:&apos;&lt;&apos;,gt:&apos;&gt;&apos;&#125;;</div><div class="line">	//返回deentityify方法</div><div class="line">	return function()&#123;</div><div class="line">		return this.replace(/&amp;([^&amp;;]+);/g,function(a,b)&#123;</div><div class="line">			var r= entity[b];</div><div class="line">			return typeof r === &apos;string&apos;?r:a;</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;())</div></pre></td></tr></table></figure></p>
<p>请注意最后一行，我们（）运算，会立即执行。模块模式利用函数的作用域与闭包，来创建绑定对象与私有成员的关联。<br>模块模式的一般形式是，一个定义了私有变量和函数的函数，利用闭包创建可以访问私有变量和函数的特权函数，最后返回这个特权函数，或者把他们保存到可以访问到的地方。<br>模块模式可以用来创建安全的对象。构造一个产生序列号的对象。<br>var serial_marker = function(){<br>    var prefix = ‘’;<br>    var seq = 0;<br>    return {set_prefix:function(p){prefix = String(p)},set_seq:function(s){seq = s;},gensym:function(){var result = prefix +seq;seq += 1;return result;}}<br>};</p>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><h3 id="套用"><a href="#套用" class="headerlink" title="套用"></a>套用</h3><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>函数可以用对象记住先前操作的结果，从而避免无谓的计算，这种优化称为“记忆”，js的对象和数组要实现这种优化是非常方便的。<br>我们想要一个递归函数，斐波那契数列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var fabonacci = function(n)&#123;</div><div class="line">	return n&lt;2?n:fabonacci(n-1)+ fabonacci(n-2);</div><div class="line">&#125;</div><div class="line">for(var i=0;i&lt;10;i++)&#123;</div><div class="line">	document.writeln(i+&quot;:&quot;+fabonacci(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在一个名为</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
            <a href="/tags/javascript语言精粹/" rel="tag"># javascript语言精粹</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/25/javascriptGoodParts3/" rel="next" title="javascript good parts 对象">
                <i class="fa fa-chevron-left"></i> javascript good parts 对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/04/面向对象/" rel="prev" title="面向对象一些segment">
                面向对象一些segment <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/01/javascriptGoodParts4/"
           data-title="javascript good parts 函数" data-url="http://guilongyue.github.io/2017/03/01/javascriptGoodParts4/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar" >
    <div class="sidebar-inner" >

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel" >
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="guilong yue" />
          <p class="site-author-name" itemprop="name">guilong yue</p>
          <p class="site-description motion-element" itemprop="description">一点浩然气，千里快哉风</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">115</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">115</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/guilongyue" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/your-user-name" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005052005322093" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/longshao1988" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
		<br/>
		<div>
		<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330px height=86px src="//music.163.com/outchain/player?type=2&id=29713754&auto=0&height=66"></iframe>
        </div>
		


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数对象"><span class="nav-number">1.0.1.</span> <span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数字面量"><span class="nav-number">1.0.2.</span> <span class="nav-text">函数字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用"><span class="nav-number">1.0.3.</span> <span class="nav-text">调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法调用模式"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">方法调用模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数调用模式"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">函数调用模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造器的调用模式"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">构造器的调用模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Apply调用模式"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">Apply调用模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数"><span class="nav-number">1.0.4.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回"><span class="nav-number">1.0.5.</span> <span class="nav-text">返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常"><span class="nav-number">1.0.6.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给类型增加方法。"><span class="nav-number">1.0.7.</span> <span class="nav-text">给类型增加方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">1.0.8.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">1.0.9.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">1.0.10.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调"><span class="nav-number">1.0.11.</span> <span class="nav-text">回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块"><span class="nav-number">1.0.12.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#级联"><span class="nav-number">1.0.13.</span> <span class="nav-text">级联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套用"><span class="nav-number">1.0.14.</span> <span class="nav-text">套用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记忆"><span class="nav-number">1.0.15.</span> <span class="nav-text">记忆</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>

    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">guilong yue</span>
</div>


<div class="powered-by">
   <a class="theme-link" href="https://guilongyue.github.io">guilong yue</a> 个人专属
</div>

<div class="theme-info">
  博客 -
  龙
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"long1111"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
