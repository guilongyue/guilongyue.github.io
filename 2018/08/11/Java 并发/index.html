<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java 并发," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Java并发分析（1）发挥多核CPU的优势随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发分析">
<meta property="og:url" content="http://guilongyue.github.io/2018/08/11/Java 并发/index.html">
<meta property="og:site_name" content="沉默的风">
<meta property="og:description" content="Java并发分析（1）发挥多核CPU的优势随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的">
<meta property="og:image" content="http://guilongyue.github.io/images/thread-state.png">
<meta property="og:image" content="http://guilongyue.github.io/images/CountdownLatch.png">
<meta property="og:image" content="http://guilongyue.github.io/images/CyclicBarrier.png">
<meta property="og:image" content="http://guilongyue.github.io/images/Semaphore.png">
<meta property="og:image" content="http://guilongyue.github.io/images/forkjoin.jpg">
<meta property="og:image" content="http://guilongyue.github.io/images/jmm1.png">
<meta property="og:image" content="http://guilongyue.github.io/images/jmm2.png">
<meta property="og:image" content="http://guilongyue.github.io/images/jmm3.png">
<meta property="og:image" content="http://guilongyue.github.io/images/jmm4.png">
<meta property="og:image" content="http://guilongyue.github.io/images/jmm5.png">
<meta property="og:image" content="http://guilongyue.github.io/images/threadLocal.png">
<meta property="og:image" content="http://guilongyue.github.io/images/lightweight-locked.png">
<meta property="og:image" content="http://guilongyue.github.io/images/lightweightlocked-2.png">
<meta property="og:image" content="http://guilongyue.github.io/images/lightweightlocked-3.png">
<meta property="og:image" content="http://guilongyue.github.io/images/biasble.png">
<meta property="og:updated_time" content="2018-08-17T03:30:30.295Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 并发分析">
<meta name="twitter:description" content="Java并发分析（1）发挥多核CPU的优势随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的">
<meta name="twitter:image" content="http://guilongyue.github.io/images/thread-state.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://guilongyue.github.io/2018/08/11/Java 并发/"/>





  <title> Java 并发分析 | 沉默的风 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">沉默的风</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://guilongyue.github.io/2018/08/11/Java 并发/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="guilong yue">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="沉默的风">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="沉默的风" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java 并发分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-11T17:13:18+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/11/Java 并发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/11/Java 并发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java并发分析"><a href="#Java并发分析" class="headerlink" title="Java并发分析"></a>Java并发分析</h1><p>（1）发挥多核CPU的优势<br>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。<br>（2）防止阻塞<br>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。<br>（3）便于建模<br>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。<br><a id="more"></a></p>
<h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img src="/images/thread-state.png" alt=""></p>
<h3 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h3><p>创建后尚未启动。</p>
<h3 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h3><p>可能正在运行，也可能正在等待 CPU 时间片。<br>包含了操作系统线程状态中的 Running 和 Ready。</p>
<h3 id="阻塞（Blocking）"><a href="#阻塞（Blocking）" class="headerlink" title="阻塞（Blocking）"></a>阻塞（Blocking）</h3><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p>
<h3 id="无限期等待（Waiting）"><a href="#无限期等待（Waiting）" class="headerlink" title="无限期等待（Waiting）"></a>无限期等待（Waiting）</h3><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="限期等待（Timed-Waiting）"><a href="#限期等待（Timed-Waiting）" class="headerlink" title="限期等待（Timed Waiting）"></a>限期等待（Timed Waiting）</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。<br>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。<br>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。<br>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>-</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="死亡（Terminated）"><a href="#死亡（Terminated）" class="headerlink" title="死亡（Terminated）"></a>死亡（Terminated）</h3><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。<br>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</li>
</ul>
<h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>需要实现 run() 方法。</p>
<p>通过 Thread 调用 start() 方法来启动线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MyRunnable implements Runnable &#123;</div><div class="line">    public void run() &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    MyRunnable instance = new MyRunnable();</div><div class="line">    Thread thread = new Thread(instance);</div><div class="line">    thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</div><div class="line">    public Integer call() &#123;</div><div class="line">        return 123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</div><div class="line">    MyCallable mc = new MyCallable();</div><div class="line">    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);</div><div class="line">    Thread thread = new Thread(ft);</div><div class="line">    thread.start();</div><div class="line">    System.out.println(ft.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MyThread extends Thread &#123;</div><div class="line">    public void run() &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    MyThread mt = new MyThread();</div><div class="line">    mt.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h3><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h2 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。<br>主要有三种 Executor：<br>CachedThreadPool：一个任务创建一个线程；<br>FixedThreadPool：所有任务只能使用固定大小的线程；<br>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。<br>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。<br>main() 属于非守护线程。<br>使用 setDaemon() 方法将一个线程设置为守护线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    Thread thread = new Thread(new MyRunnable());</div><div class="line">    thread.setDaemon(true);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。<br>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(3000);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">    Thread.yield();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>通过调用一个线程的interrupt()来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断I/O 阻塞和 synchronized 锁阻塞。<br>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class InterruptExample &#123;</div><div class="line">    private static class MyThread1 extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(2000);</div><div class="line">                System.out.println(&quot;Thread run&quot;);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    Thread thread1 = new MyThread1();</div><div class="line">    thread1.start();</div><div class="line">    thread1.interrupt();</div><div class="line">    System.out.println(&quot;Main run&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h3><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class InterruptExample &#123;</div><div class="line">    private static class MyThread2 extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            while (!interrupted()) &#123;</div><div class="line">                // ..</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;Thread end&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    Thread thread2 = new MyThread2();</div><div class="line">    thread2.start();</div><div class="line">    thread2.interrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    executorService.execute(() -&gt; &#123;</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(2000);</div><div class="line">            System.out.println(&quot;Thread run&quot;);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    executorService.shutdownNow();</div><div class="line">    System.out.println(&quot;Main run&quot;);</div><div class="line">&#125;</div><div class="line">Main run</div><div class="line">java.lang.InterruptedException: sleep interrupted</div><div class="line">    at java.lang.Thread.sleep(Native Method)</div><div class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</div><div class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</div><div class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div class="line">    at java.lang.Thread.run(Thread.java:745)</div></pre></td></tr></table></figure></p>
<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</div><div class="line">    // ..</div><div class="line">&#125;);</div><div class="line">future.cancel(true);</div></pre></td></tr></table></figure></p>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的ReentrantLock。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ol>
<li>同步一个代码块<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void func() &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。<br>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedExample &#123;</div><div class="line"></div><div class="line">    public void func1() &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                System.out.print(i + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    SynchronizedExample e1 = new SynchronizedExample();</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    executorService.execute(() -&gt; e1.func1());</div><div class="line">    executorService.execute(() -&gt; e1.func1());</div><div class="line">&#125;</div><div class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</div></pre></td></tr></table></figure></p>
<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    SynchronizedExample e1 = new SynchronizedExample();</div><div class="line">    SynchronizedExample e2 = new SynchronizedExample();</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    executorService.execute(() -&gt; e1.func1());</div><div class="line">    executorService.execute(() -&gt; e2.func1());</div><div class="line">&#125;</div><div class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</div></pre></td></tr></table></figure></p>
<ol>
<li>同步一个方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized void func () &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>它和同步代码块一样，作用于同一个对象。</p>
<ol>
<li>同步一个类<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void func() &#123;</div><div class="line">    synchronized (SynchronizedExample.class) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedExample &#123;</div><div class="line"></div><div class="line">    public void func2() &#123;</div><div class="line">        synchronized (SynchronizedExample.class) &#123;</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                System.out.print(i + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    SynchronizedExample e1 = new SynchronizedExample();</div><div class="line">    SynchronizedExample e2 = new SynchronizedExample();</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    executorService.execute(() -&gt; e1.func2());</div><div class="line">    executorService.execute(() -&gt; e2.func2());</div><div class="line">&#125;</div><div class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</div></pre></td></tr></table></figure></p>
<ol>
<li>同步一个静态方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized static void fun() &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>作用于整个类。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class LockExample &#123;</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">    public void func() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                System.out.print(i + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock(); // 确保释放锁，从而避免发生死锁。</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    LockExample lockExample = new LockExample();</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    executorService.execute(() -&gt; lockExample.func());</div><div class="line">    executorService.execute(() -&gt; lockExample.func());</div><div class="line">&#125;</div><div class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</div></pre></td></tr></table></figure></p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol>
<li>锁的实现<br>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li>
<li><p>性能<br>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
</li>
<li><p>等待可中断<br>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，而 synchronized 不行。</p>
</li>
<li><p>公平锁<br>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
</li>
<li><p>锁绑定多个条件<br>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
</li>
</ol>
<h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。<br>对于以下代码，虽然 b 线程先启动，但是因为在 b线程中调用了a线程的 join() 方法，b线程会等待 a线程结束才继续执行，因此最后能够保证a线程的输出先于b线程的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class JoinExample &#123;</div><div class="line"></div><div class="line">    private class A extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(&quot;A&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class B extends Thread &#123;</div><div class="line"></div><div class="line">        private A a;</div><div class="line"></div><div class="line">        B(A a) &#123;</div><div class="line">            this.a = a;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                a.join();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;B&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void test() &#123;</div><div class="line">        A a = new A();</div><div class="line">        B b = new B(a);</div><div class="line">        b.start();</div><div class="line">        a.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    JoinExample example = new JoinExample();</div><div class="line">    example.test();</div><div class="line">&#125;</div><div class="line">A</div><div class="line">B</div></pre></td></tr></table></figure></p>
<h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。<br>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。<br>使用wait()挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class WaitNotifyExample &#123;</div><div class="line">    public synchronized void before() &#123;</div><div class="line">        System.out.println(&quot;before&quot;);</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void after() &#123;</div><div class="line">        try &#123;</div><div class="line">            wait();</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;after&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    WaitNotifyExample example = new WaitNotifyExample();</div><div class="line">    executorService.execute(() -&gt; example.after());</div><div class="line">    executorService.execute(() -&gt; example.before());</div><div class="line">&#125;</div><div class="line">before</div><div class="line">after</div></pre></td></tr></table></figure></p>
<p>wait() 和 sleep() 的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</div><div class="line">wait() 会释放锁，sleep() 不会。</div></pre></td></tr></table></figure></p>
<h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class AwaitSignalExample &#123;</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">    private Condition condition = lock.newCondition();</div><div class="line"></div><div class="line">    public void before() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;before&quot;);</div><div class="line">            condition.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void after() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            condition.await();</div><div class="line">            System.out.println(&quot;after&quot;);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    AwaitSignalExample example = new AwaitSignalExample();</div><div class="line">    executorService.execute(() -&gt; example.after());</div><div class="line">    executorService.execute(() -&gt; example.before());</div><div class="line">&#125;</div><div class="line">before</div><div class="line">after</div></pre></td></tr></table></figure></p>
<h2 id="J-U-C-AQS"><a href="#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h2><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p>用来控制一个线程等待多个线程。<br>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。<br><img src="/images/CountdownLatch.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class CountdownLatchExample &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final int totalThread = 10;</div><div class="line">        CountDownLatch countDownLatch = new CountDownLatch(totalThread);</div><div class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">        for (int i = 0; i &lt; totalThread; i++) &#123;</div><div class="line">            executorService.execute(() -&gt; &#123;</div><div class="line">                System.out.print(&quot;run..&quot;);</div><div class="line">                countDownLatch.countDown();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        countDownLatch.await();</div><div class="line">        System.out.println(&quot;end&quot;);</div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">run..run..run..run..run..run..run..run..run..run..end</div></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。<br>和CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await()方法之后计数器会减 1，并进行等待，直到计数器为0，所有调用awati()方法而在等待的线程才能继续执行。<br>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。<br>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</div><div class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</div><div class="line">    this.parties = parties;</div><div class="line">    this.count = parties;</div><div class="line">    this.barrierCommand = barrierAction;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public CyclicBarrier(int parties) &#123;</div><div class="line">    this(parties, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/images/CyclicBarrier.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierExample &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final int totalThread = 10;</div><div class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);</div><div class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">        for (int i = 0; i &lt; totalThread; i++) &#123;</div><div class="line">            executorService.execute(() -&gt; &#123;</div><div class="line">                System.out.print(&quot;before..&quot;);</div><div class="line">                try &#123;</div><div class="line">                    cyclicBarrier.await();</div><div class="line">                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.print(&quot;after..&quot;);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</div></pre></td></tr></table></figure></p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore 就是操作系统中的信号量，可以控制对互斥资源的访问线程数。<br><img src="/images/Semaphore.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</div><div class="line"></div><div class="line">public class SemaphoreExample &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final int clientCount = 3;</div><div class="line">        final int totalRequestCount = 10;</div><div class="line">        Semaphore semaphore = new Semaphore(clientCount);</div><div class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">        for (int i = 0; i &lt; totalRequestCount; i++) &#123;</div><div class="line">            executorService.execute(()-&gt;&#123;</div><div class="line">                try &#123;</div><div class="line">                    semaphore.acquire();</div><div class="line">                    System.out.print(semaphore.availablePermits() + &quot; &quot;);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    semaphore.release();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">2 1 2 2 2 2 2 1 2 2</div></pre></td></tr></table></figure></p>
<h2 id="J-U-C-其它组件"><a href="#J-U-C-其它组件" class="headerlink" title="J.U.C - 其它组件"></a>J.U.C - 其它组件</h2><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</div><div class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</div></pre></td></tr></table></figure></p>
<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class FutureTaskExample &#123;</div><div class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</div><div class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Integer call() throws Exception &#123;</div><div class="line">                int result = 0;</div><div class="line">                for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                    Thread.sleep(10);</div><div class="line">                    result += i;</div><div class="line">                &#125;</div><div class="line">                return result;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread computeThread = new Thread(futureTask);</div><div class="line">        computeThread.start();</div><div class="line"></div><div class="line">        Thread otherThread = new Thread(() -&gt; &#123;</div><div class="line">            System.out.println(&quot;other task is running...&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        otherThread.start();</div><div class="line">        System.out.println(futureTask.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">other task is running...</div><div class="line">4950</div></pre></td></tr></table></figure></p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<br>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）<br>优先级队列 ：PriorityBlockingQueue<br>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。<br>使用 BlockingQueue 实现生产者消费者问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class ProducerConsumer &#123;</div><div class="line"></div><div class="line">    private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);</div><div class="line"></div><div class="line">    private static class Producer extends Thread &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                queue.put(&quot;product&quot;);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.print(&quot;produce..&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Consumer extends Thread &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                String product = queue.take();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.print(&quot;consume..&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    for (int i = 0; i &lt; 2; i++) &#123;</div><div class="line">        Producer producer = new Producer();</div><div class="line">        producer.start();</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">        Consumer consumer = new Consumer();</div><div class="line">        consumer.start();</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">        Producer producer = new Producer();</div><div class="line">        producer.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</div></pre></td></tr></table></figure></p>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; &#123;</div><div class="line">    private final int threshold = 5;</div><div class="line">    private int first;</div><div class="line">    private int last;</div><div class="line"></div><div class="line">    public ForkJoinExample(int first, int last) &#123;</div><div class="line">        this.first = first;</div><div class="line">        this.last = last;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Integer compute() &#123;</div><div class="line">        int result = 0;</div><div class="line">        if (last - first &lt;= threshold) &#123;</div><div class="line">            // 任务足够小则直接计算</div><div class="line">            for (int i = first; i &lt;= last; i++) &#123;</div><div class="line">                result += i;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 拆分成小任务</div><div class="line">            int middle = first + (last - first) / 2;</div><div class="line">            ForkJoinExample leftTask = new ForkJoinExample(first, middle);</div><div class="line">            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);</div><div class="line">            leftTask.fork();</div><div class="line">            rightTask.fork();</div><div class="line">            result = leftTask.join() + rightTask.join();</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</div><div class="line">    ForkJoinExample example = new ForkJoinExample(1, 10000);</div><div class="line">    ForkJoinPool forkJoinPool = new ForkJoinPool();</div><div class="line">    Future result = forkJoinPool.submit(example);</div><div class="line">    System.out.println(result.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class ForkJoinPool extends AbstractExecutorService</div></pre></td></tr></table></figure></p>
<p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。<br><img src="/images/forkjoin.jpg" alt=""></p>
<h2 id="线程不安全示例"><a href="#线程不安全示例" class="headerlink" title="线程不安全示例"></a>线程不安全示例</h2><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。<br>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值为 997 而不是 1000。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class ThreadUnsafeExample &#123;</div><div class="line"></div><div class="line">    private int cnt = 0;</div><div class="line"></div><div class="line">    public void add() &#123;</div><div class="line">        cnt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int get() &#123;</div><div class="line">        return cnt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    final int threadSize = 1000;</div><div class="line">    ThreadUnsafeExample example = new ThreadUnsafeExample();</div><div class="line">    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    for (int i = 0; i &lt; threadSize; i++) &#123;</div><div class="line">        executorService.execute(() -&gt; &#123;</div><div class="line">            example.add();</div><div class="line">            countDownLatch.countDown();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    countDownLatch.await();</div><div class="line">    executorService.shutdown();</div><div class="line">    System.out.println(example.get());</div><div class="line">&#125;</div><div class="line">997</div></pre></td></tr></table></figure></p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。<br>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。<br><img src="/images/jmm1.png" alt=""><br>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。<br>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。<br><img src="/images/jmm2.png" alt=""></p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java内存模型定义了8个操作来完成主内存和工作内存的交互操作。<br><img src="/images/jmm3.png" alt=""></p>
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock<h3 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h3></li>
</ul>
<ol>
<li>原子性<br>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。<br>有一个错误认识就是，int 等原子性的变量在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 变量属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。<br>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。<br>下图演示了两个线程同时对 cnt 变量进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入该变量的值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。<br><img src="/images/jmm4.png" alt=""><br>AtomicInteger 能保证多个线程修改的原子性。<br><img src="/images/jmm5.png" alt=""><br>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AtomicExample &#123;</div><div class="line">    private AtomicInteger cnt = new AtomicInteger();</div><div class="line"></div><div class="line">    public void add() &#123;</div><div class="line">        cnt.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int get() &#123;</div><div class="line">        return cnt.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    final int threadSize = 1000;</div><div class="line">    AtomicExample example = new AtomicExample(); // 只修改这条语句</div><div class="line">    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    for (int i = 0; i &lt; threadSize; i++) &#123;</div><div class="line">        executorService.execute(() -&gt; &#123;</div><div class="line">            example.add();</div><div class="line">            countDownLatch.countDown();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    countDownLatch.await();</div><div class="line">    executorService.shutdown();</div><div class="line">    System.out.println(example.get());</div><div class="line">&#125;</div><div class="line">1000</div></pre></td></tr></table></figure>
<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class AtomicSynchronizedExample &#123;</div><div class="line">    private int cnt = 0;</div><div class="line"></div><div class="line">    public synchronized void add() &#123;</div><div class="line">        cnt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized int get() &#123;</div><div class="line">        return cnt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    final int threadSize = 1000;</div><div class="line">    AtomicSynchronizedExample example = new AtomicSynchronizedExample();</div><div class="line">    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    for (int i = 0; i &lt; threadSize; i++) &#123;</div><div class="line">        executorService.execute(() -&gt; &#123;</div><div class="line">            example.add();</div><div class="line">            countDownLatch.countDown();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    countDownLatch.await();</div><div class="line">    executorService.shutdown();</div><div class="line">    System.out.println(example.get());</div><div class="line">&#125;</div><div class="line">1000</div></pre></td></tr></table></figure></p>
<ol>
<li>可见性<br>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。<br>主要有有三种实现可见性的方式：</li>
</ol>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。<br>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</li>
</ul>
<ol>
<li>有序性<br>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。<br>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。<br>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</li>
</ol>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<ol>
<li><p>单一线程原则</p>
<blockquote>
<p>Single Thread rule<br>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
</blockquote>
</li>
<li><p>管程锁定规则</p>
<blockquote>
<p>Monitor Lock Rule<br>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
</blockquote>
</li>
<li>volatile 变量规则<blockquote>
<p>Volatile Variable Rule<br>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
</blockquote>
</li>
<li>线程启动规则<blockquote>
<p>Thread Start Rule<br>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
</blockquote>
</li>
<li>线程加入规则<blockquote>
<p>Thread Join Rule<br>Thread 对象的结束先行发生于 join() 方法返回。</p>
</blockquote>
</li>
<li>线程中断规则<blockquote>
<p>Thread Interruption Rule<br>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
</blockquote>
</li>
<li>对象终结规则<blockquote>
<p>Finalizer Rule<br>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
</blockquote>
</li>
<li>传递性<blockquote>
<p>Transitivity<br>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
</blockquote>
</li>
</ol>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全定义<br>一个类在可以被多个线程安全调用时就是线程安全的。</p>
<h3 id="线程安全分类"><a href="#线程安全分类" class="headerlink" title="线程安全分类"></a>线程安全分类</h3><p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h4><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。<br>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。<br>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
<li>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ImmutableExample &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</div><div class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</div><div class="line">        unmodifiableMap.put(&quot;a&quot;, 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</div><div class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)</div><div class="line">    at ImmutableExample.main(ImmutableExample.java:9)</div><div class="line">Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</div><div class="line"></div><div class="line">public V put(K key, V value) &#123;</div><div class="line">    throw new UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2. 绝对线程安全"></a>2. 绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3. 相对线程安全"></a>3. 相对线程安全</h4><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。<br>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。<br>对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class VectorUnsafeExample &#123;</div><div class="line">    private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">                vector.add(i);</div><div class="line">            &#125;</div><div class="line">            ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">            executorService.execute(() -&gt; &#123;</div><div class="line">                for (int i = 0; i &lt; vector.size(); i++) &#123;</div><div class="line">                    vector.remove(i);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            executorService.execute(() -&gt; &#123;</div><div class="line">                for (int i = 0; i &lt; vector.size(); i++) &#123;</div><div class="line">                    vector.get(i);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            executorService.shutdown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Exception in thread &quot;Thread-159738&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3</div><div class="line">    at java.util.Vector.remove(Vector.java:831)</div><div class="line">    at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14)</div><div class="line">    at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source)</div><div class="line">    at java.lang.Thread.run(Thread.java:745)</div></pre></td></tr></table></figure>
<p>如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">executorService.execute(() -&gt; &#123;</div><div class="line">    synchronized (vector) &#123;</div><div class="line">        for (int i = 0; i &lt; vector.size(); i++) &#123;</div><div class="line">            vector.remove(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">executorService.execute(() -&gt; &#123;</div><div class="line">    synchronized (vector) &#123;</div><div class="line">        for (int i = 0; i &lt; vector.size(); i++) &#123;</div><div class="line">            vector.get(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4. 线程兼容"></a>4. 线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p>
<h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5. 线程对立"></a>5. 线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1. 互斥同步"></a>1. 互斥同步</h3><p>synchronized 和 ReentrantLock。</p>
<h3 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2. 非阻塞同步"></a>2. 非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。<br>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。<br>（一）CAS<br>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。<br>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。<br>（二）AtomicInteger<br>J.U.C 包里面的整数原子类 AtomicInteger，其中的compareAndSet()和getAndIncrement()等方法都使用了 Unsafe 类的 CAS 操作。<br>以下代码使用了 AtomicInteger 执行了自增的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private AtomicInteger cnt = new AtomicInteger();</div><div class="line">public void add() &#123;</div><div class="line">    cnt.incrementAndGet();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final int incrementAndGet() &#123;</div><div class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。<br>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</div><div class="line">    int var5;</div><div class="line">    do &#123;</div><div class="line">        var5 = this.getIntVolatile(var1, var2);</div><div class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</div><div class="line"></div><div class="line">    return var5;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（三）ABA<br>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。<br>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证CAS的正确性。大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。<br>（一）栈封闭<br>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line">public class StackClosedExample &#123;</div><div class="line">    public void add100() &#123;</div><div class="line">        int cnt = 0;</div><div class="line">        for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">            cnt++;</div><div class="line">        &#125;</div><div class="line">        System.out.println(cnt);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    StackClosedExample example = new StackClosedExample();</div><div class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">    executorService.execute(() -&gt; example.add100());</div><div class="line">    executorService.execute(() -&gt; example.add100());</div><div class="line">    executorService.shutdown();</div><div class="line">&#125;</div><div class="line">100</div><div class="line">100</div></pre></td></tr></table></figure></p>
<p>（二）线程本地存储（Thread Local Storage）<br>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。<br>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。<br>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalExample &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ThreadLocal threadLocal = new ThreadLocal();</div><div class="line">        Thread thread1 = new Thread(() -&gt; &#123;</div><div class="line">            threadLocal.set(1);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(threadLocal.get());</div><div class="line">            threadLocal.remove();</div><div class="line">        &#125;);</div><div class="line">        Thread thread2 = new Thread(() -&gt; &#123;</div><div class="line">            threadLocal.set(2);</div><div class="line">            threadLocal.remove();</div><div class="line">        &#125;);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>为了理解 ThreadLocal，先看以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalExample1 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ThreadLocal threadLocal1 = new ThreadLocal();</div><div class="line">        ThreadLocal threadLocal2 = new ThreadLocal();</div><div class="line">        Thread thread1 = new Thread(() -&gt; &#123;</div><div class="line">            threadLocal1.set(1);</div><div class="line">            threadLocal2.set(1);</div><div class="line">        &#125;);</div><div class="line">        Thread thread2 = new Thread(() -&gt; &#123;</div><div class="line">            threadLocal1.set(2);</div><div class="line">            threadLocal2.set(2);</div><div class="line">        &#125;);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它所对应的底层结构图为：<br><img src="/images/threadLocal.png" alt=""><br>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象，Thread 类中就定义了 ThreadLocal.ThreadLocalMap 成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</div><div class="line"> * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure></p>
<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>get() 方法类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。<br>十二、锁优化<br>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static String concatString(String s1, String s2, String s3) &#123;</div><div class="line">    return s1 + s2 + s3;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static String concatString(String s1, String s2, String s3) &#123;</div><div class="line">    StringBuffer sb = new StringBuffer();</div><div class="line">    sb.append(s1);</div><div class="line">    sb.append(s2);</div><div class="line">    sb.append(s3);</div><div class="line">    return sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。<br><img src="/images/lightweight-locked.png" alt=""></p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。<br><img src="/images/lightweightlocked-2.png" alt=""></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。<br><img src="/images/lightweightlocked-3.png" alt=""></p>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连CAS操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。<br><img src="/images/biasble.png" alt=""></p>
<h2 id="多线程开发良好的实践"><a href="#多线程开发良好的实践" class="headerlink" title="多线程开发良好的实践"></a>多线程开发良好的实践</h2><ul>
<li>给线程起个有意义的名字，这样可以方便找Bug。</li>
<li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li>
<li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li>
<li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li>
<li>使用本地变量和不可变类来保证线程安全。</li>
<li>使用线程池而不是直接创建 Thread 对象，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>
<li>使用 BlockingQueue 实现生产者消费者问题。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java-并发/" rel="tag"># java 并发</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/09/Java IO分析/" rel="next" title="Java IO 分析">
                <i class="fa fa-chevron-left"></i> Java IO 分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/12/Java 容器/" rel="prev" title="Java 容器分析">
                Java 容器分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/08/11/Java 并发/"
           data-title="Java 并发分析" data-url="http://guilongyue.github.io/2018/08/11/Java 并发/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar" >
    <div class="sidebar-inner" >

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel" >
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="guilong yue" />
          <p class="site-author-name" itemprop="name">guilong yue</p>
          <p class="site-description motion-element" itemprop="description">一点浩然气，千里快哉风</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">106</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">104</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/guilongyue" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/your-user-name" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005052005322093" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/longshao1988" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
		<br/>
		<div>
		<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330px height=86px src="//music.163.com/outchain/player?type=2&id=29713754&auto=0&height=66"></iframe>
        </div>
		


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发分析"><span class="nav-number">1.</span> <span class="nav-text">Java并发分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态转换"><span class="nav-number">1.1.</span> <span class="nav-text">线程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新建（New）"><span class="nav-number">1.1.1.</span> <span class="nav-text">新建（New）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可运行（Runnable）"><span class="nav-number">1.1.2.</span> <span class="nav-text">可运行（Runnable）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞（Blocking）"><span class="nav-number">1.1.3.</span> <span class="nav-text">阻塞（Blocking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无限期等待（Waiting）"><span class="nav-number">1.1.4.</span> <span class="nav-text">无限期等待（Waiting）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限期等待（Timed-Waiting）"><span class="nav-number">1.1.5.</span> <span class="nav-text">限期等待（Timed Waiting）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死亡（Terminated）"><span class="nav-number">1.1.6.</span> <span class="nav-text">死亡（Terminated）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用线程"><span class="nav-number">1.2.</span> <span class="nav-text">使用线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-Runnable-接口"><span class="nav-number">1.2.1.</span> <span class="nav-text">实现 Runnable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-Callable-接口"><span class="nav-number">1.2.2.</span> <span class="nav-text">实现 Callable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Thread类"><span class="nav-number">1.2.3.</span> <span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现接口-VS-继承-Thread"><span class="nav-number">1.2.4.</span> <span class="nav-text">实现接口 VS 继承 Thread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础线程机制"><span class="nav-number">1.3.</span> <span class="nav-text">基础线程机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">1.3.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon"><span class="nav-number">1.3.2.</span> <span class="nav-text">Daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep"><span class="nav-number">1.3.3.</span> <span class="nav-text">sleep()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield"><span class="nav-number">1.3.4.</span> <span class="nav-text">yield()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、中断"><span class="nav-number">1.4.</span> <span class="nav-text">四、中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InterruptedException"><span class="nav-number">1.4.1.</span> <span class="nav-text">InterruptedException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupted"><span class="nav-number">1.4.2.</span> <span class="nav-text">interrupted()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor-的中断操作"><span class="nav-number">1.4.3.</span> <span class="nav-text">Executor 的中断操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥同步"><span class="nav-number">1.5.</span> <span class="nav-text">互斥同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">1.5.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.5.2.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较"><span class="nav-number">1.5.3.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用选择"><span class="nav-number">1.5.4.</span> <span class="nav-text">使用选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程之间的协作"><span class="nav-number">1.6.</span> <span class="nav-text">线程之间的协作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#join"><span class="nav-number">1.6.1.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-notify-notifyAll"><span class="nav-number">1.6.2.</span> <span class="nav-text">wait() notify() notifyAll()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#await-signal-signalAll"><span class="nav-number">1.6.3.</span> <span class="nav-text">await() signal() signalAll()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#J-U-C-AQS"><span class="nav-number">1.7.</span> <span class="nav-text">J.U.C - AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountdownLatch"><span class="nav-number">1.7.1.</span> <span class="nav-text">CountdownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">1.7.2.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.7.3.</span> <span class="nav-text">Semaphore</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#J-U-C-其它组件"><span class="nav-number">1.8.</span> <span class="nav-text">J.U.C - 其它组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask"><span class="nav-number">1.8.1.</span> <span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">1.8.2.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoin"><span class="nav-number">1.8.3.</span> <span class="nav-text">ForkJoin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程不安全示例"><span class="nav-number">1.9.</span> <span class="nav-text">线程不安全示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-内存模型"><span class="nav-number">1.10.</span> <span class="nav-text">Java 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主内存与工作内存"><span class="nav-number">1.10.1.</span> <span class="nav-text">主内存与工作内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存间交互操作"><span class="nav-number">1.10.2.</span> <span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存模型三大特性"><span class="nav-number">1.10.3.</span> <span class="nav-text">内存模型三大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先行发生原则"><span class="nav-number">1.10.4.</span> <span class="nav-text">先行发生原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全"><span class="nav-number">1.11.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全分类"><span class="nav-number">1.11.1.</span> <span class="nav-text">线程安全分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-不可变"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">1. 不可变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-绝对线程安全"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">2. 绝对线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-相对线程安全"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">3. 相对线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-线程兼容"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">4. 线程兼容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-线程对立"><span class="nav-number">1.11.1.5.</span> <span class="nav-text">5. 线程对立</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全的实现方法"><span class="nav-number">1.12.</span> <span class="nav-text">线程安全的实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-互斥同步"><span class="nav-number">1.12.1.</span> <span class="nav-text">1. 互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-非阻塞同步"><span class="nav-number">1.12.2.</span> <span class="nav-text">2. 非阻塞同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-无同步方案"><span class="nav-number">1.12.3.</span> <span class="nav-text">3.无同步方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">1.12.4.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁消除"><span class="nav-number">1.12.5.</span> <span class="nav-text">锁消除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁粗化"><span class="nav-number">1.13.</span> <span class="nav-text">锁粗化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-number">1.13.1.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">1.13.2.</span> <span class="nav-text">偏向锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程开发良好的实践"><span class="nav-number">1.14.</span> <span class="nav-text">多线程开发良好的实践</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>

    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">guilong yue</span>
</div>


<div class="powered-by">
   <a class="theme-link" href="https://guilongyue.github.io">guilong yue</a> 个人专属
</div>

<div class="theme-info">
  博客 -
  龙
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"long1111"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
